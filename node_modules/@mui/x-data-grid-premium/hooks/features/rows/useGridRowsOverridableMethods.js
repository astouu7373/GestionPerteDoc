"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridRowsOverridableMethods = void 0;
var React = _interopRequireWildcard(require("react"));
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _internals = require("@mui/x-data-grid-pro/internals");
var _reorderExecutor = require("../rowReorder/reorderExecutor");
const useGridRowsOverridableMethods = (apiRef, props) => {
  const {
    processRowUpdate,
    onProcessRowUpdateError
  } = props;
  const {
    setRowIndex: setRowIndexPlain
  } = (0, _internals.useGridRowsOverridableMethods)(apiRef);
  const flatTree = (0, _internals.useGridSelector)(apiRef, _xDataGridPro.gridRowMaximumTreeDepthSelector) === 1;
  const setRowIndex = React.useCallback(async (sourceRowId, targetOriginalIndex) => {
    const sortedFilteredRowIds = (0, _xDataGridPro.gridExpandedSortedRowIdsSelector)(apiRef);
    const sortedFilteredRowIndexLookup = (0, _internals.gridExpandedSortedRowIndexLookupSelector)(apiRef);
    const rowTree = (0, _xDataGridPro.gridRowTreeSelector)(apiRef);
    const sourceNode = (0, _xDataGridPro.gridRowNodeSelector)(apiRef, sourceRowId);
    if (!sourceNode) {
      throw new Error(`MUI X: No row with id #${sourceRowId} found.`);
    }
    if (sourceNode.type === 'footer') {
      throw new Error(`MUI X: The row reordering do not support reordering of footer rows.`);
    }

    /**
     * Row Grouping Reordering Use Cases
     * =================================
     *
     * | Case | Source Node | Target Node | Parent Relationship       | Action                                                                      |
     * | :--- | :---------- | :---------- | :------------------------ | :-------------------------------------------------------------------------- |
     * | A ✅ | Leaf        | Leaf        | Same parent               | Swap positions (similar to flat tree structure)                             |
     * | B ✅ | Group       | Group       | Same parent               | Swap positions (along with their descendants)                               |
     * | C ✅ | Leaf        | Leaf        | Different parents         | Make source node a child of target's parent and update parent nodes in tree |
     * | D ✅ | Leaf        | Group       | Different parents         | Make source a child of target, only allowed at same depth as source.parent  |
     * | E ❌ | Leaf        | Group       | Target is source's parent | Not allowed, will have no difference                                        |
     * | F ❌ | Group       | Leaf        | Any                       | Not allowed, will break the row grouping criteria                           |
     * | G ✅ | Group       | Group       | Different parents         | Only allowed at same depth to preserve grouping criteria                    |
     */

    const executionContext = {
      sourceRowId,
      placeholderIndex: targetOriginalIndex,
      sortedFilteredRowIds,
      sortedFilteredRowIndexLookup,
      rowTree,
      apiRef,
      processRowUpdate,
      onProcessRowUpdateError
    };
    await _reorderExecutor.rowGroupingReorderExecutor.execute(executionContext);
  }, [apiRef, processRowUpdate, onProcessRowUpdateError]);
  return {
    setRowIndex: flatTree ? setRowIndexPlain : setRowIndex
  };
};
exports.useGridRowsOverridableMethods = useGridRowsOverridableMethods;