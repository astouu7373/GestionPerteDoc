"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rowGroupingReorderValidator = void 0;
var _utils = require("./utils");
const validationRules = [
// ===== Basic invalid cases =====
{
  name: 'same-position',
  applies: ctx => ctx.sourceRowIndex === ctx.targetRowIndex,
  isInvalid: () => true,
  message: 'Source and target are the same'
}, {
  name: 'adjacent-position',
  applies: ctx => _utils.conditions.isAdjacentPosition(ctx),
  isInvalid: () => true,
  message: 'Source and target are adjacent'
}, {
  name: 'group-to-leaf',
  applies: _utils.conditions.isGroupToLeaf,
  isInvalid: () => true,
  message: 'Cannot drop group on leaf'
},
// ===== Group to Group Rules =====
{
  name: 'group-to-group-above-leaf-belongs-to-source',
  applies: ctx => _utils.conditions.isGroupToGroup(ctx) && _utils.conditions.isDropAbove(ctx) && _utils.conditions.prevIsLeaf(ctx),
  isInvalid: _utils.conditions.prevBelongsToSource,
  message: 'Previous leaf belongs to source group or its descendants'
}, {
  name: 'group-to-group-above-invalid-depth',
  applies: ctx => _utils.conditions.isGroupToGroup(ctx) && _utils.conditions.isDropAbove(ctx) && !_utils.conditions.sameDepth(ctx) && !(ctx.targetNode.depth < ctx.sourceNode.depth && (_utils.conditions.prevIsLeaf(ctx) || _utils.conditions.prevIsGroup(ctx) && _utils.conditions.prevDepthEqualsSource(ctx))),
  isInvalid: () => true,
  message: 'Invalid depth configuration for group above group'
}, {
  name: 'group-to-group-above-different-parent-depth',
  applies: ctx => _utils.conditions.isGroupToGroup(ctx) && _utils.conditions.isDropAbove(ctx) && _utils.conditions.prevIsGroup(ctx) && _utils.conditions.prevDepthEqualsSource(ctx) && _utils.conditions.targetGroupExpanded(ctx),
  isInvalid: ctx => ctx.prevNode.depth !== ctx.sourceNode.depth,
  message: 'Cannot reorder groups with different depths'
}, {
  name: 'group-to-group-below-invalid-config',
  applies: ctx => _utils.conditions.isGroupToGroup(ctx) && _utils.conditions.isDropBelow(ctx),
  isInvalid: ctx => {
    // Valid case 1: Same depth and target not expanded
    if (_utils.conditions.sameDepth(ctx) && _utils.conditions.targetGroupCollapsed(ctx)) {
      return false;
    }
    // Valid case 2: Target is parent level, expanded, with compatible first child
    if (_utils.conditions.targetDepthIsSourceMinusOne(ctx) && _utils.conditions.targetGroupExpanded(ctx) && _utils.conditions.targetFirstChildIsGroupWithSourceDepth(ctx)) {
      return false;
    }
    return true;
  },
  message: 'Invalid group below group configuration'
},
// ===== Leaf to Leaf Rules =====
{
  name: 'leaf-to-leaf-different-depth',
  applies: ctx => _utils.conditions.isLeafToLeaf(ctx) && !_utils.conditions.sameDepth(ctx),
  isInvalid: () => true,
  message: 'Leaves at different depths cannot be reordered'
}, {
  name: 'leaf-to-leaf-invalid-below',
  applies: ctx => _utils.conditions.isLeafToLeaf(ctx) && _utils.conditions.sameDepth(ctx) && !_utils.conditions.sameParent(ctx) && _utils.conditions.isDropBelow(ctx),
  isInvalid: ctx => !(_utils.conditions.nextIsGroup(ctx) && ctx.sourceNode.depth > ctx.nextNode.depth) && !_utils.conditions.nextIsLeaf(ctx),
  message: 'Invalid leaf below leaf configuration'
},
// ===== Leaf to Group Rules =====
{
  name: 'leaf-to-group-above-no-prev-leaf',
  applies: ctx => _utils.conditions.isLeafToGroup(ctx) && _utils.conditions.isDropAbove(ctx),
  isInvalid: ctx => !_utils.conditions.hasPrevNode(ctx) || !_utils.conditions.prevIsLeaf(ctx),
  message: 'No valid previous leaf for leaf above group'
}, {
  name: 'leaf-to-group-above-depth-mismatch',
  applies: ctx => _utils.conditions.isLeafToGroup(ctx) && _utils.conditions.isDropAbove(ctx) && _utils.conditions.prevIsLeaf(ctx) && !(ctx.sourceNode.depth > ctx.targetNode.depth && ctx.targetNode.depth === 0),
  isInvalid: ctx => ctx.prevNode.depth !== ctx.sourceNode.depth,
  message: 'Previous node depth mismatch for leaf above group'
}, {
  name: 'leaf-to-group-below-collapsed',
  applies: ctx => _utils.conditions.isLeafToGroup(ctx) && _utils.conditions.isDropBelow(ctx),
  isInvalid: _utils.conditions.targetGroupCollapsed,
  message: 'Cannot drop below collapsed group'
}, {
  name: 'leaf-to-group-below-invalid-depth',
  applies: ctx => _utils.conditions.isLeafToGroup(ctx) && _utils.conditions.isDropBelow(ctx) && _utils.conditions.targetGroupExpanded(ctx),
  isInvalid: ctx => {
    // Valid case 1: Target is parent level
    if (ctx.sourceNode.depth > ctx.targetNode.depth && ctx.targetNode.depth === ctx.sourceNode.depth - 1) {
      return false;
    }
    // Valid case 2: First child has same depth as source
    if (_utils.conditions.targetFirstChildDepthEqualsSource(ctx)) {
      return false;
    }
    return true;
  },
  message: 'Invalid depth configuration for leaf below group'
}];
class RowReorderValidator {
  constructor(rules = validationRules) {
    this.rules = rules;
  }
  addRule(rule) {
    this.rules.push(rule);
  }
  removeRule(ruleName) {
    this.rules = this.rules.filter(r => r.name !== ruleName);
  }
  validate(context) {
    // Check all validation rules
    for (const rule of this.rules) {
      if (rule.applies(context) && rule.isInvalid(context)) {
        return false;
      }
    }
    return true;
  }
}
const rowGroupingReorderValidator = exports.rowGroupingReorderValidator = new RowReorderValidator(validationRules);