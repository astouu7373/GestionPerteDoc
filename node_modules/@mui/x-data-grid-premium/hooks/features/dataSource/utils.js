"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPropsOverrides = exports.fetchParents = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _xDataGridPro = require("@mui/x-data-grid-pro");
const getPropsOverrides = (pivotColumns, pivotingColDef, pivotModel, initialColumns, apiRef) => {
  const visiblePivotColumns = pivotModel.columns.filter(column => !column.hidden);
  const visiblePivotValues = pivotModel.values.filter(value => !value.hidden);
  const columns = Array.from(initialColumns.values());

  // Build column grouping model from pivot column paths
  const columnGroupingModel = [];
  const columnGroupingModelLookup = new Map();

  // Build new columns lookup and ordered fields
  const newColumns = {};

  // Build aggregation model
  const aggregationModel = {};

  // Create unique combinations of all values from pivotColumns and pivotValues
  const uniquePaths = [];
  const processPath = (currentPath, remainingColumns, level) => {
    if (level === visiblePivotColumns.length) {
      uniquePaths.push([...currentPath]);
      return;
    }
    remainingColumns.forEach(column => {
      processPath([...currentPath, {
        key: column.key,
        field: visiblePivotColumns[level].field,
        value: column.group
      }], column.children || [], level + 1);
    });
  };
  processPath([], pivotColumns, 0);

  /**
   * Column group headers are sorted by the leaf columns order in the column definition.
   * Store the values of each column group path to be able to sort them by pivot column sort order.
   * The values are stored by the column group level which allows easier sorting by going through the column group levels in reverse order.
   * Store raw value to be able to determine if the value was formatted on the client using `getRowValue`.
   * Values sent from the server as strings will not be sorted on the client.
   */
  const columnGroupPathValues = [];
  uniquePaths.forEach(columnPath => {
    const columnPathKeys = columnPath.map(path => path.key);
    const columnPathValues = columnPath.map(path => path.value);
    visiblePivotValues.forEach(pivotValue => {
      // Find the original column definition for the last field
      const originalColumn = initialColumns.get(pivotValue.field);
      // get the overrides defined from the data source definition
      const overrides = pivotingColDef(pivotValue.field, columnPathKeys);

      // Create new column definition based on original column
      const newColumnDef = (0, _extends2.default)({}, originalColumn, overrides, {
        aggregable: false,
        groupable: false,
        filterable: false,
        hideable: false,
        editable: false,
        disableReorder: true
      });
      const pivotFieldName = newColumnDef.field;
      newColumns[pivotFieldName] = newColumnDef;
      aggregationModel[pivotFieldName] = pivotValue.aggFunc;

      // Build column grouping model
      const combinedPathValues = [...columnPathValues, pivotValue.field].map((path, index) => typeof path === 'string' ? path : apiRef.current.getRowValue(path, initialColumns.get(visiblePivotColumns[index].field)));
      columnGroupPathValues.push({
        field: pivotFieldName,
        pathValues: combinedPathValues.slice(0, -1),
        pathValuesRaw: columnPathValues
      });

      // Build the hierarchy for column groups
      for (let i = 0; i < combinedPathValues.length - 1; i += 1) {
        const currentField = visiblePivotColumns[i].field;
        const groupPath = combinedPathValues.slice(0, i + 1);
        const groupId = groupPath.join('-');
        let headerName = columnPathValues[groupPath.length - 1];
        if (typeof headerName !== 'string') {
          headerName = apiRef.current.getRowFormattedValue(headerName, initialColumns.get(currentField));
        }
        if (typeof headerName === 'number') {
          headerName = String(headerName);
        }
        if (typeof headerName !== 'string') {
          throw new Error(`MUI X: Header name for a column group based on ${currentField} cannot be converted to a string.`);
        }
        if (!columnGroupingModelLookup.has(groupId)) {
          const columnGroup = {
            groupId,
            headerName,
            children: []
          };
          columnGroupingModelLookup.set(groupId, columnGroup);
          if (i === 0) {
            columnGroupingModel.push(columnGroup);
          } else {
            const parentGroupId = groupPath.slice(0, -1).join('-');
            const parentGroup = columnGroupingModelLookup.get(parentGroupId);
            if (parentGroup) {
              parentGroup.children.push(columnGroup);
            }
          }
        }
      }

      // Add the final column to the appropriate group
      const parentGroupId = combinedPathValues.slice(0, -1).join('-');
      const parentGroup = columnGroupingModelLookup.get(parentGroupId);
      if (parentGroup) {
        parentGroup.children.push({
          field: pivotFieldName
        });
      }
    });
  });
  for (let i = visiblePivotColumns.length - 1; i >= 0; i -= 1) {
    const sort = visiblePivotColumns[i].sort;
    if (!sort) {
      continue;
    }
    columnGroupPathValues.sort((a, b) => {
      // Do not sort values that are returned as strings
      if (typeof a.pathValuesRaw[i] === 'string' && typeof b.pathValuesRaw[i] === 'string') {
        return 0;
      }
      return (sort === 'asc' ? 1 : -1) * (0, _xDataGridPro.gridStringOrNumberComparator)(a.pathValues[i], b.pathValues[i], {}, {});
    });
  }
  if (visiblePivotColumns.length > 0) {
    for (let i = 0; i < columnGroupPathValues.length; i += 1) {
      columns.push(newColumns[columnGroupPathValues[i].field]);
    }
  }
  return {
    columns,
    columnGroupingModel,
    aggregationModel
  };
};
exports.getPropsOverrides = getPropsOverrides;
const fetchParents = (rowTree, rowId, fetchHandler) => {
  const parents = [];

  // collect all parents ids
  let currentId = rowId;
  while (currentId !== undefined && currentId !== _xDataGridPro.GRID_ROOT_GROUP_ID) {
    const parentId = rowTree[currentId].parent;
    parents.push(parentId);
    currentId = parentId;
  }
  return Promise.all(parents.reverse().map(fetchHandler));
};
exports.fetchParents = fetchParents;