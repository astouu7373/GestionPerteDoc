"use strict";
'use client';

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridDataSourcePremium = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _isDeepEqual = require("@mui/x-internals/isDeepEqual");
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _internals = require("@mui/x-data-grid-pro/internals");
var _gridPivotingSelectors = require("../pivoting/gridPivotingSelectors");
var _utils = require("./utils");
var _gridRowGroupingSelector = require("../rowGrouping/gridRowGroupingSelector");
var _gridAggregationSelectors = require("../aggregation/gridAggregationSelectors");
function getKeyPremium(params) {
  return JSON.stringify([params.filterModel, params.sortModel, params.groupKeys, params.groupFields, params.start, params.end, params.pivotModel ? {} : params.aggregationModel, params.pivotModel]);
}
const options = {
  cacheOptions: {
    getKey: getKeyPremium
  }
};
const useGridDataSourcePremium = (apiRef, props) => {
  const aggregationModel = (0, _gridAggregationSelectors.gridAggregationModelSelector)(apiRef);
  const groupingModelSize = (0, _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector)(apiRef).length;
  const setStrategyAvailability = React.useCallback(() => {
    const targetStrategy = props.treeData || !props.disableRowGrouping && groupingModelSize > 0 ? _internals.DataSourceRowsUpdateStrategy.GroupedData : _internals.DataSourceRowsUpdateStrategy.Default;
    apiRef.current.setStrategyAvailability(_internals.GridStrategyGroup.DataSource, targetStrategy, props.dataSource && !props.lazyLoading ? () => true : () => false);
  }, [apiRef, props.dataSource, props.lazyLoading, props.treeData, props.disableRowGrouping, groupingModelSize]);
  const handleEditRowWithAggregation = React.useCallback((params, updatedRow) => {
    const rowTree = (0, _xDataGridPro.gridRowTreeSelector)(apiRef);
    if (updatedRow && !(0, _isDeepEqual.isDeepEqual)(updatedRow, params.previousRow)) {
      // Reset the outdated cache, only if the row is _actually_ updated
      apiRef.current.dataSource.cache.clear();
    }
    const groupKeys = (0, _internals.getGroupKeys)(rowTree, params.rowId);
    apiRef.current.updateNestedRows([updatedRow], groupKeys);
    // To refresh the aggregation values of all parent rows and the footer row, recursively re-fetch all parent levels
    (0, _utils.fetchParents)(rowTree, params.rowId, apiRef.current.dataSource.fetchRows);
  }, [apiRef]);
  const {
    api,
    debouncedFetchRows,
    flatTreeStrategyProcessor,
    groupedDataStrategyProcessor,
    events
  } = (0, _internals.useGridDataSourceBasePro)(apiRef, props, (0, _extends2.default)({}, !props.disableAggregation && Object.keys(aggregationModel).length > 0 ? {
    handleEditRow: handleEditRowWithAggregation
  } : {}, options));
  const aggregateRowRef = React.useRef({});
  const initialColumns = (0, _internals.gridPivotInitialColumnsSelector)(apiRef);
  const pivotActive = (0, _internals.gridPivotActiveSelector)(apiRef);
  const pivotModel = (0, _gridPivotingSelectors.gridPivotModelSelector)(apiRef);
  const processDataSourceRows = React.useCallback(({
    params,
    response
  }, applyRowHydration) => {
    if (response.aggregateRow) {
      aggregateRowRef.current = response.aggregateRow;
    }
    if (Object.keys(params.aggregationModel || {}).length > 0) {
      if (applyRowHydration) {
        apiRef.current.requestPipeProcessorsApplication('hydrateRows');
      }
      apiRef.current.applyAggregation();
    }
    if (response.pivotColumns) {
      const pivotingColDef = props.pivotingColDef;
      if (!pivotingColDef || typeof pivotingColDef !== 'function') {
        throw new Error('MUI X: No `pivotingColDef()` prop provided with to the Data Grid, but response contains `pivotColumns`.\n\n\
            You need a callback to return at least a field column prop for each generated pivot column.\n\n\
            See [server-side pivoting](https://mui.com/x/react-data-grid/server-side-data/pivoting/) documentation for more details.');
      }

      // Update the grid state with new columns and column grouping model
      const partialPropsOverrides = (0, _utils.getPropsOverrides)(response.pivotColumns, pivotingColDef, pivotModel, initialColumns, apiRef);
      apiRef.current.setState(state => {
        return (0, _extends2.default)({}, state, {
          pivoting: (0, _extends2.default)({}, state.pivoting, {
            propsOverrides: (0, _extends2.default)({}, state.pivoting.propsOverrides, partialPropsOverrides)
          })
        });
      });
    }
    return {
      params,
      response
    };
  }, [apiRef, props.pivotingColDef, initialColumns, pivotModel]);
  const resolveGroupAggregation = React.useCallback((groupId, field) => {
    if (groupId === _xDataGridPro.GRID_ROOT_GROUP_ID) {
      return props.dataSource?.getAggregatedValue?.(aggregateRowRef.current, field);
    }
    const row = apiRef.current.getRow(groupId);
    return props.dataSource?.getAggregatedValue?.(row, field);
  }, [apiRef, props.dataSource]);
  const privateApi = (0, _extends2.default)({}, api.private, {
    resolveGroupAggregation
  });
  (0, _xDataGridPro.useGridApiMethod)(apiRef, api.public, 'public');
  (0, _xDataGridPro.useGridApiMethod)(apiRef, privateApi, 'private');
  (0, _internals.useGridRegisterStrategyProcessor)(apiRef, flatTreeStrategyProcessor.strategyName, flatTreeStrategyProcessor.group, flatTreeStrategyProcessor.processor);
  (0, _internals.useGridRegisterStrategyProcessor)(apiRef, groupedDataStrategyProcessor.strategyName, groupedDataStrategyProcessor.group, groupedDataStrategyProcessor.processor);
  (0, _internals.useGridRegisterPipeProcessor)(apiRef, 'processDataSourceRows', processDataSourceRows);
  Object.entries(events).forEach(([event, handler]) => {
    (0, _xDataGridPro.useGridEvent)(apiRef, event, handler);
  });
  (0, _xDataGridPro.useGridEvent)(apiRef, 'rowGroupingModelChange', (0, _internals.runIf)(!pivotActive, () => debouncedFetchRows()));
  (0, _xDataGridPro.useGridEvent)(apiRef, 'aggregationModelChange', (0, _internals.runIf)(!pivotActive, () => debouncedFetchRows()));
  (0, _xDataGridPro.useGridEvent)(apiRef, 'pivotModeChange', (0, _internals.runIf)(!pivotActive, () => debouncedFetchRows()));
  (0, _xDataGridPro.useGridEvent)(apiRef, 'pivotModelChange', (0, _internals.runIf)(pivotActive, () => debouncedFetchRows()));
  React.useEffect(() => {
    setStrategyAvailability();
  }, [setStrategyAvailability]);
};
exports.useGridDataSourcePremium = useGridDataSourcePremium;