import type { RefObject } from '@mui/x-internals/types';
import { type GridRowId, type GridTreeNode, type GridGroupNode, type GridRowTreeConfig, type GridKeyValue, type GridValidRowModel } from '@mui/x-data-grid-pro';
import type { RowTreeBuilderGroupingCriterion } from '@mui/x-data-grid-pro/internals';
import type { ReorderValidationContext as Ctx, ReorderOperationType } from "./types.js";
import type { GridPrivateApiPremium } from "../../../models/gridApiPremium.js";
import { DataGridPremiumProcessedProps } from "../../../models/dataGridPremiumProps.js";
/**
 * Reusable validation conditions for row reordering validation
 */
export declare const conditions: {
  isGroupToGroup: (ctx: Ctx) => boolean;
  isLeafToLeaf: (ctx: Ctx) => boolean;
  isLeafToGroup: (ctx: Ctx) => boolean;
  isGroupToLeaf: (ctx: Ctx) => boolean;
  isDropAbove: (ctx: Ctx) => boolean;
  isDropBelow: (ctx: Ctx) => boolean;
  sameDepth: (ctx: Ctx) => boolean;
  sourceDepthGreater: (ctx: Ctx) => boolean;
  targetDepthIsSourceMinusOne: (ctx: Ctx) => boolean;
  sameParent: (ctx: Ctx) => boolean;
  targetGroupExpanded: (ctx: Ctx) => boolean;
  targetGroupCollapsed: (ctx: Ctx) => boolean;
  hasPrevNode: (ctx: Ctx) => boolean;
  hasNextNode: (ctx: Ctx) => boolean;
  prevIsLeaf: (ctx: Ctx) => boolean;
  prevIsGroup: (ctx: Ctx) => boolean;
  nextIsLeaf: (ctx: Ctx) => boolean;
  nextIsGroup: (ctx: Ctx) => boolean;
  prevDepthEquals: (ctx: Ctx, depth: number) => boolean;
  prevDepthEqualsSource: (ctx: Ctx) => boolean;
  prevBelongsToSource: (ctx: Ctx) => boolean;
  isAdjacentPosition: (ctx: Ctx) => boolean;
  targetFirstChildIsGroupWithSourceDepth: (ctx: Ctx) => boolean;
  targetFirstChildDepthEqualsSource: (ctx: Ctx) => boolean;
};
export declare function determineOperationType(sourceNode: GridTreeNode, targetNode: GridTreeNode): ReorderOperationType;
export declare function calculateTargetIndex(sourceNode: GridTreeNode, targetNode: GridTreeNode, isLastChild: boolean, rowTree: Record<GridRowId, GridTreeNode>): number;
export declare const getNodePathInTree: ({
  id,
  tree
}: {
  id: GridRowId;
  tree: GridRowTreeConfig;
}) => RowTreeBuilderGroupingCriterion[];
export declare const collectAllLeafDescendants: (groupNode: GridGroupNode, tree: GridRowTreeConfig) => GridRowId[];
/**
 * Adjusts the target node based on specific reorder scenarios and constraints.
 *
 * This function applies scenario-specific logic to find the actual target node
 * for operations, handling cases like:
 * - Moving to collapsed groups
 * - Depth-based adjustments
 * - End-of-list positioning
 *
 * @param sourceNode The node being moved
 * @param targetNode The initial target node
 * @param targetIndex The index of the target node in the visible rows
 * @param placeholderIndex The index where the placeholder appears
 * @param sortedFilteredRowIds Array of visible row IDs in display order
 * @param apiRef Reference to the grid API
 * @returns Object containing the adjusted target node and last child flag
 */
export declare function adjustTargetNode(sourceNode: GridTreeNode, targetNode: GridTreeNode, targetIndex: number, placeholderIndex: number, sortedFilteredRowIds: GridRowId[], apiRef: RefObject<GridPrivateApiPremium>): {
  adjustedTargetNode: GridTreeNode;
  isLastChild: boolean;
};
/**
 * Finds an existing group node with the same groupingKey and groupingField under a parent.
 *
 * @param parentNode - The parent group node to search in
 * @param groupingKey - The grouping key to match
 * @param groupingField - The grouping field to match
 * @param tree - The row tree configuration
 * @returns The existing group node if found, null otherwise
 */
export declare function findExistingGroupWithSameKey(parentNode: GridGroupNode, groupingKey: GridKeyValue, groupingField: string, tree: GridRowTreeConfig): GridGroupNode | null;
/**
 * Removes empty ancestor groups from the tree after a row move operation.
 * Walks up the tree from the given group, removing any empty groups encountered.
 *
 * @param groupId - The ID of the group to start checking from
 * @param tree - The row tree configuration
 * @param removedGroups - Set to track which groups have been removed
 * @returns The number of root-level groups that were removed
 */
export declare function removeEmptyAncestors(groupId: GridRowId, tree: GridRowTreeConfig, removedGroups: Set<GridRowId>): number;
export declare function handleProcessRowUpdateError(error: any, onProcessRowUpdateError?: DataGridPremiumProcessedProps['onProcessRowUpdateError']): void;
/**
 * Handles batch row updates with partial failure tracking.
 *
 * This class is designed for operations that need to update multiple rows
 * atomically (like moving entire groups), while gracefully handling cases
 * where some updates succeed and others fail.
 *
 * @example
 * ```tsx
 * const updater = new BatchRowUpdater(processRowUpdate, onError);
 *
 * // Queue multiple updates
 * updater.queueUpdate('row1', originalRow1, newRow1);
 * updater.queueUpdate('row2', originalRow2, newRow2);
 *
 * // Execute all updates
 * const { successful, failed, updates } = await updater.executeAll();
 *
 * // Handle results
 * if (successful.length > 0) {
 *   apiRef.current.updateRows(updates);
 * }
 * ```
 */
export declare class BatchRowUpdater {
  private processRowUpdate;
  private onProcessRowUpdateError;
  private rowsToUpdate;
  private originalRows;
  private successfulRowIds;
  private failedRowIds;
  private pendingRowUpdates;
  constructor(processRowUpdate: DataGridPremiumProcessedProps['processRowUpdate'] | undefined, onProcessRowUpdateError: DataGridPremiumProcessedProps['onProcessRowUpdateError'] | undefined);
  queueUpdate(rowId: GridRowId, originalRow: GridValidRowModel, updatedRow: GridValidRowModel): void;
  executeAll(): Promise<{
    successful: GridRowId[];
    failed: GridRowId[];
    updates: GridValidRowModel[];
  }>;
}